<!DOCTYPE html>
<!--
PLEASE don't judge me on this code - this does not reflect my best work in 
any way. I am strictly writing these experiments as a "for fun" activity,
and as such, I write them as fast as I can so I can use them myself.
I know that I'm not following a lot of best practices.

Feel free to visit my github for better code:
https://github.com/krazykylep/

As for the license, you may do whatever you want with the code.
If you are really strict, assume the MIT license: 
http://opensource.org/licenses/MIT
-->
<html>
<head>
<meta charset="UTF-8">
<title>Elementary Cellular Automata</title>
<link rel="stylesheet" href="../css/cellular_automata.css" />
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"></script>
<script type="text/javascript">
var canvas;
var pixelSelect;
var mainCanvasContext;
var pixelSelectContext;
var pixelSelectCanvasXY;
var canvasXY;
var cwid;
var chei;
var cellwid;
var cellhei;
var rule = [];
var initialState = [];
var rowSize = 0;
var colSize = 0;
var rowBuffer1 = [];
var rowBuffer2 = [];
var renderingRow = 0;
var nonBlockingDraw = true;
var gridWrap = true;
var showingData = false;
var clearCanvasBeforeRender = true;
var renderOnStateChange = false;

var pixelSelectBarX;
var pixelSelectBarCol;

var editorCells;
var mouseDown = false;

$(document).ready(function(){
  canvas = $("#canvas");
  pixelSelect = $("#pixelSelect");

  mainCanvasContext = canvas.get(0).getContext('2d');
  pixelSelectContext = pixelSelect.get(0).getContext('2d');

  pixelSelectCanvasXY = getpos(pixelSelect);

  setRule($("#ruleNum").val());
  editorCells = $(".editorCell");

  changeCanvas(true);
  drawPixelSelectBar();
  updatePixelSelectEditor();

  pixelSelect.mousedown(function(e){
    var x = e.pageX;
    x -= pixelSelectCanvasXY.x;
    mouseDown = true;

    pixelSelectBarCol = Math.floor(x/cellwid);
    pixelSelectBarX = pixelSelectBarCol * cellwid;

    drawPixelSelectBar();
    updatePixelSelectEditor();
  });

  $(document).mousemove(function(e){
    if(!mouseDown){
      return;
    }
    var x = e.pageX;
    x -= pixelSelectCanvasXY.x;
    mouseDown = true;

    pixelSelectBarCol = Math.floor(x/cellwid);
    pixelSelectBarX = pixelSelectBarCol * cellwid;

    drawPixelSelectBar();
    updatePixelSelectEditor();
  });

  $(document).mouseup(function(){
    mouseDown = false;
    pixelSelectBarCol = Math.max(Math.min(pixelSelectBarCol, rowSize-1), 0);
    pixelSelectBarX = pixelSelectBarCol * cellwid;
    drawPixelSelectBar();
    updatePixelSelectEditor();
  });

  pixelSelect.mouseup(function(){
    mouseDown = false;
  });

  editorCells.mousedown(function(e){
    var ele = $(e.target);
    var index;
    if (e.target.id === 'searchLeft') {
      pixelSelectBarCol -= 5;
      pixelSelectBarCol = Math.max(pixelSelectBarCol, 0);
      pixelSelectBarX = pixelSelectBarCol*cellwid;
      drawPixelSelectBar();
      updatePixelSelectEditor();
    } else if (e.target.id === 'searchRight') {
      pixelSelectBarCol += 5;
      pixelSelectBarCol = Math.min(pixelSelectBarCol, rowSize-1);
      pixelSelectBarX = pixelSelectBarCol*cellwid;
      drawPixelSelectBar();
      updatePixelSelectEditor();
    } else {
      index = ele.html();
      initialState[index] = !initialState[index];
      if (initialState[index]) {
        mainCanvasContext.fillStyle = "#000000";
        ele.removeClass("editorCellOff").addClass("editorCellOn");
      } else {
        mainCanvasContext.fillStyle = "#ffffff";
        ele.removeClass("editorCellOn").addClass("editorCellOff");
      }

      drawCell(index, 0, true);
      mainCanvasContext.fillStyle = "#000000";

      if (renderOnStateChange) {
        if (clearCanvasBeforeRender) {
          clearCanvas();
        }
        startFullSimulation();
      }

      if (showingData) {
        updateData();
      }
    }
  });

  $(".rule-btn").click(function(e){
    var ele = $(e.target);
    var idx = e.target.id.slice(-1);
    if (ele.hasClass('alive')) {
      ele.removeClass("alive").addClass("dead");
      rule[idx] = false;
    } else {
      ele.removeClass("dead").addClass("alive");
      rule[idx] = true;
    }

    parseRule();
  });

  $("#save").click(function(){
    saveCanvas();
  });

  $("#apply").click(function(){
    changeCanvas();
  });

  $("#resetInitialCondition").click(function(){
    resetInitialCondition();
    if (showingData) {
      updateData();
    }
  });

  $("#clearbtn").click(function(){
    clearCanvas();
  });

  $("#random").click(function(){
    randomize();
    if (showingData) {
      updateData();
    }
  });

  $("#clearBeforeRender").click(function(e){
    if ($(e.target).is(':checked')) {
      clearCanvasBeforeRender = true;
    } else {
      clearCanvasBeforeRender = false;
      alert("With this setting off, the canvas will not update to size changes either.");
    }
  });

  $("#renderOnStateChange").click(function(e){
    if ($(e.target).is(':checked')) {
      renderOnStateChange = true;
    } else {
      renderOnStateChange = false;
    }
  });

  $("#showInitCondData").click(function(e){
    var input = $("#initCondData");
    var importBtn = $("#import");
    if (input[0].style.display === "none") {
      showingData = true;
      input.show();
      importBtn.show();
      updateData();
    } else {
      showingData = false;
      input.hide();
      importBtn.hide();
    }
  });

  $("#import").click(function(){
    var dataString = $("#initCondData").val();
    var dataStringLen = dataString.length;
    $("#cwid").val(cellwid * dataStringLen);
    initialState = Array(dataStringLen);
    for (var t=0; t<dataStringLen; ++t) {
      initialState[t] = (dataString[t] === '1');
    }
    changeCanvas();
  });

  $("#ruleNum").keyup(function(e){
    setRule(e.target.value);
  });
});

function parseRule() {
  var ruleStr = "";
  for (var t = 7; t > -1; --t) {
    ruleStr += $("#rule"+t).hasClass("alive")+0;
  }
  $("#ruleNum").val(parseInt(ruleStr, 2));
}

function setRule(ruleNum) {
  if (isNaN(ruleNum)) {
    return;
  }
  var binary = parseInt(ruleNum).toString(2);
  var len = binary.length - 1;
  for (var t = 0; t < 8; ++t) {
    var idx = len - t;
    var alive;
    if (idx < 0) {
      alive = false;
    } else {
      alive = binary[idx] === '1';
    }
    rule[t] = alive;
    if (alive) {
      $("#rule"+t).removeClass("dead").addClass("alive");
    } else {
      $("#rule"+t).removeClass("alive").addClass("dead");
    }
  }
}

function randInt(low, high){
  return Math.floor(Math.random()*(high-low+1))+low;
}

function clearCanvas(){
  mainCanvasContext.fillStyle = 'white';
  mainCanvasContext.fillRect(0,0,cwid,chei);
}

function changeCanvas(start) {
  var midPoint;

  cwid = $("#cwid").val();
  chei = $("#chei").val();

  cellhei = $("#cellhei").val();
  cellwid = $("#cellwid").val();

  nonBlockingDraw = $("#nonBlock").is(':checked');
  gridWrap = $("#gridWrap").is(':checked');

  colSize = Math.floor(chei/cellhei);
  rowSize = Math.floor(cwid/cellwid);

  midPoint = Math.floor(rowSize/2);

  if (start) {
    initialState = Array(rowSize);
    initialState[midPoint] = true;
    pixelSelectBarX = midPoint*cellwid;
    pixelSelectBarCol = midPoint;
  } else {
    initialState = overlayArrays(new Array(rowSize), initialState);
    pixelSelectBarCol = Math.min(pixelSelectBarCol, rowSize-1);
    pixelSelectBarX = pixelSelectBarCol * cellwid;
  }

  if (showingData) {
    updateData();
  }

  if (clearCanvasBeforeRender) {
    $("#canvasDiv").css("width", cwid);
    $("#canvasDiv").css("height", chei);
    canvas.attr("width", cwid);
    canvas.attr("height", chei);

    $("#pixelSelectDiv").css("width", cwid);
    $("#pixelSelectDiv").css("height", "20px");
    pixelSelect.attr("width", cwid);
    pixelSelect.attr("height", 20);

    drawPixelSelectBar();
    updatePixelSelectEditor();
    clearCanvas();
  }
  startFullSimulation();
}

function startFullSimulation() {
  var x = 0;
  var y = 0;
  var tempBuffer;
  rowBuffer1 = cloneArray(initialState);
  mainCanvasContext.fillStyle = '#000000';

  if (nonBlockingDraw) {
    renderingRow = 0;
    renderRow();
  } else {
    for (y = 0; y < colSize; ++y) {
      for (x = 0; x < rowSize; ++x) {
        drawCell(x, y, analyzeCell(x, y));
      }
      tempBuffer = rowBuffer1;
      rowBuffer1 = rowBuffer2;
      rowBuffer2 = tempBuffer;
    }
  }
}

function renderRow() {
  var y = renderingRow;
  for (x = 0; x < rowSize; ++x) {
    drawCell(x, y, analyzeCell(x, y));
  }
  tempBuffer = rowBuffer1;
  rowBuffer1 = rowBuffer2;
  rowBuffer2 = tempBuffer;
  ++renderingRow;
  if (y < colSize) {
    if (y%4 !== 0) {
      renderRow();
    } else {
      setTimeout(renderRow, 0);
    }
  }
}

function analyzeCell(x) {
  var left = x-1;
  var right = x+1;
  if (gridWrap) {
    if (left < 0) {
      left = rowSize-1;
    }
    if (right > rowSize-1) {
      right = 0;
    }
  }
  var lookup = ((!!rowBuffer1[left]) << 2) + (rowBuffer1[x] << 1) + (!!rowBuffer1[right]);
  rowBuffer2[x] = rule[lookup];
  return rowBuffer1[x];
}

function drawCell(x, y, alive) {
  if (!alive) {
    if (clearCanvasBeforeRender) {
      return;
    }
    mainCanvasContext.fillStyle = '#ffffff';
  } else {
    mainCanvasContext.fillStyle = '#000000';
  }
  mainCanvasContext.fillRect(x*cellwid, y*cellhei, cellwid, cellhei);
}

function drawPixelSelectBar() {
  pixelSelectContext.fillStyle = "#ffffff";
  pixelSelectContext.fillRect(0, 0, cwid, 20);
  pixelSelectContext.fillStyle = "#ff0000";
  pixelSelectContext.fillRect(pixelSelectBarX-(5*cellwid), 0, cellwid*11, 20);
}

function updatePixelSelectEditor() {
  var upperLimit = pixelSelectBarCol + 6;
  var cell = 1;
  for (var t = pixelSelectBarCol-5; t < upperLimit; ++t) {
    if (t < 0 || t > rowSize-1) {
      editorCells.eq(cell).text("").removeClass("editorCellOn").addClass("editorCellOff");
    } else {
      editorCells.eq(cell).text(t);
      if (initialState[t]) {
        editorCells.eq(cell).removeClass("editorCellOff").addClass("editorCellOn");
      } else {
        editorCells.eq(cell).removeClass("editorCellOn").addClass("editorCellOff");
      }
    }
    ++cell;
  }
}

function cloneArray(arr) {
  var arrLen = arr.length;
  var out = Array(arrLen);
  for (var t = 0; t < arrLen; ++t) {
    out[t] = arr[t];
  }
  return out;
}

function overlayArrays(target, src) {
  var targetLen = target.length;
  var srcLen = src.length;
  var x = 0;
  var y = 0;

  while (x < targetLen && y < srcLen) {
    target[x] = src[y];
    ++x;
    ++y;
  }
  return target;
}

function getpos(o) {
  return { x:o.offset().left, y:o.offset().top };
}

function randomize() {
  var roll;
  for (var t = 0; t < rowSize-1; ++t) {
    roll = randInt(1,6);
    if (roll === 1) {
      initialState[t] = true;
    } else {
      initialState[t] = false;
    }
  }
  updatePixelSelectEditor();
  changeCanvas();
}

function resetInitialCondition() {
  initialState = Array(rowSize);
  updatePixelSelectEditor();
  mainCanvasContext.fillStyle = "#ffffff";
  mainCanvasContext.fillRect(0, 0, cwid, cellhei);
  mainCanvasContext.fillStyle = "#000000";
}

function updateData() {
  var ans = "";
  for (var t=0; t<rowSize; ++t) {
    if (initialState[t]) {
      ans += "1";
    } else {
      ans += "0";
    }
  }
  $("#initCondData").val(ans);
}

function saveCanvas() {
  window.open(canvas[0].toDataURL("image/png"));
}
</script>
</head>
<body>
  <a href="../experiments.html"><-- Back</a>
  <h1>Elementary Cellular Automata with HTML5 Canvas</h1>
  <h3>Works best in Firefox or Google Chrome.</h3>
  <b>Instructions:</b><br/>
  <ul>
    <li>A black filled in cell is considered 'alive' while a white one is 'dead'.</li>
    <li>Decide your rules by either typing in the rule number in the textbox or by clicking the small squares under the rows of 3 squares.</li>
    <li>Use the red rectangle to scroll around a close up view of the top row where you can input the initial conditions.</li>
    <li>Click on the cell number to toggle that initial condition on or off.</li>
  </ul>
  <div class="left">
    <table>
      <tr><td>
      Canvas Height:
      </td><td>
      <input type="text" id="chei" value="400" />
      </td><td>
      Cell Height:
      </td><td>
      <input type="text" id="cellhei" value="2" />
      </td></tr>
      <tr><td>
      Canvas Width:
      </td><td>
      <input type="text" id="cwid" value="600" />
      </td><td>
      Cell Width:
      </td><td>
      <input type="text" id="cellwid" value="2" />
      </td></tr>
    </table>
    <div class="rule-div rule-input-div">
      Rule:<br>
      <input id="ruleNum" maxlength="3" value="90">
    </div>
    <div class="rule-div">
      <div class="alive"></div><div class="alive"></div><div class="alive"></div><br>
      <div id="rule7" class="dead rule-btn"></div>
    </div>
    <div class="rule-div">
      <div class="alive"></div><div class="alive"></div><div class="dead"></div><br>
      <div id="rule6" class="dead rule-btn"></div>
    </div>
    <div class="rule-div">
      <div class="alive"></div><div class="dead"></div><div class="alive"></div><br>
      <div id="rule5" class="dead rule-btn"></div>
    </div>
    <div class="rule-div">
      <div class="alive"></div><div class="dead"></div><div class="dead"></div><br>
      <div id="rule4" class="dead rule-btn"></div>
    </div>
    <div class="rule-div">
      <div class="dead"></div><div class="alive"></div><div class="alive"></div><br>
      <div id="rule3" class="dead rule-btn"></div>
    </div>
    <div class="rule-div">
      <div class="dead"></div><div class="alive"></div><div class="dead"></div><br>
      <div id="rule2" class="dead rule-btn"></div>
    </div>
    <div class="rule-div">
      <div class="dead"></div><div class="dead"></div><div class="alive"></div><br>
      <div id="rule1" class="dead rule-btn"></div>
    </div>
    <div class="rule-div">
      <div class="dead"></div><div class="dead"></div><div class="dead"></div><br>
      <div id="rule0" class="dead rule-btn"></div>
    </div>
    <div class="clearfix">
      Non Blocking Draw: <input type="checkbox" id="nonBlock" checked="checked">
      Grid Wrap: <input type="checkbox" id="gridWrap" checked="checked">
      Show Initial Condition Data: <input type="checkbox" id="showInitCondData"><br>
      Clear Canvas Before Rendering: <input type="checkbox" id="clearBeforeRender" checked="checked">
      Render On Initial State Change: <input type="checkbox" id="renderOnStateChange"><br>
      <input type="button" value="Apply Settings &amp; Redraw" id="apply">
      <input type="button" value="Render Random" id="random">
      <input type="button" value="Clear Canvas" id="clearbtn">
      <input type="button" value="Clear Initial Condition" id="resetInitialCondition">
      <input type="button" value="Save Canvas as PNG" id="save"><br>
      <input type="text" id="initCondData">
      <input type="button" value="Import Data" id="import">
    </div>
    <div id="pixelEditor">
      <div class="editorCell" id="searchLeft">&#171;</div>
      <div class="editorCell"></div>
      <div class="editorCell"></div>
      <div class="editorCell"></div>
      <div class="editorCell"></div>
      <div class="editorCell"></div>
      <div class="editorCell"></div>
      <div class="editorCell"></div>
      <div class="editorCell"></div>
      <div class="editorCell"></div>
      <div class="editorCell"></div>
      <div class="editorCell"></div>
      <div class="editorCell" id="searchRight">&#187;</div>
    </div>
  </div>
  <div class="canvas-wrapper">
    <div id="pixelSelectDiv">
      <canvas id="pixelSelect"></canvas>
    </div>
    <div id="canvasDiv">
      <canvas id="canvas"></canvas>
    </div>
  </div>

  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-40905210-1', 'kylepaulsen.com');
    ga('send', 'pageview');
  </script>
</body>
</html>